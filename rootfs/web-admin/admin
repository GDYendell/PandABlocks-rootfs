#!/bin/sh

# Administration cgi interface.

header()
{
    cat <<EOF
Content-type: text/html

<html>
<head>
<title>$@</title>
<link rel="stylesheet" type="text/css" href="/style.css">
</head>
<body>
<h1>$@</h1>
EOF
}

footer()
{
    cat <<EOF
<p><a href="/">Top</a>
</body>
</html>
EOF
}


fail()
{
    header Action failed
    echo "$@"
    footer
    exit
}


check_usb_device()
{
    for file in /mnt/*; do
        [ -d $file ]  &&  return
    done
    fail Action not allowed
}


pre()
{
    echo '<pre>'
    "$@"
    echo '</pre>'
}


do_list()
{
    header Installed files
    pre zpkg list
    footer
}


# The first argument is the navigation directory, the second is our current
# location in the navigation, the third is the title.
list_directories()
{
    dir_list="$(find "/mnt$2" -xdev -mindepth 1 -maxdepth 1 -type d)"

    if [ -n "$dir_list" ]; then
        cat <<EOF
<h2>Select directory containing $3:</h2>
<ul class="dirlist">
EOF
        echo "$dir_list" |
        while read -r; do
            dir=${REPLY#/mnt/}
            cat <<EOF
<li><a href="/cgi-bin/admin/$1/$dir">$dir</a></li>
EOF
        done
        echo '</ul>'
    fi
}


show_back()
{
    if [ "$2" != '' -a "$2" != / ]; then
        cat <<EOF
<p>Up to <a href="/cgi-bin/admin/$1${2%/*}">/mnt$(dirname "$2")</a>
EOF
    fi
}


do_files()
{
    [ -d "/mnt$1" ]  ||  fail Invalid directory

    header "Looking for packages in /mnt$1"

    list_directories mnt "$1" 'packages to install'

    zpg_list="$(
        find "/mnt$1" -xdev -mindepth 1 -maxdepth 1 -type f -name *.zpg)"
    if [ -n "$zpg_list" ]; then
        cat <<EOF
<h2>Select packages to install:</h2>
<form action="/cgi-bin/admin/install" method="get">
<ul class="zpglist">
EOF

        echo "$zpg_list" |
        while read -r; do
        cat <<EOF
<li><input type="checkbox" name="zpg" value="$REPLY">${REPLY##*/}</li>
EOF
        done
        cat <<EOF
</ul>
<input type="submit" value="Install Selected">
</form>
EOF
    fi

    if [ -z "$dir_list" -a -z "$zpg_list" ]; then
        echo '<p>Nothing found'
    fi

    show_back mnt "$1"
    footer
}


urldecode()
{
    python -c 'import sys, urllib; print urllib.unquote(sys.argv[1])' "$@"
}


# Computes a list of packages from $QUERY_STRING
package_list()
{
    IFS=\&
    for file in $QUERY_STRING; do
        file="$(urldecode "$file")"
        printf ' %s' "${file#zpg=}"
    done
    echo
    IFS=' '
}


do_install()
{
    header Installing

    install_args="$(package_list)"

    # Now do the install.
    cat <<EOF
<p>Running command:
<pre>zpkg install $install_args</pre>
EOF

    echo '<pre>'
    zpkg install $install_args  ||
        echo Install failed with error code $?
    echo '</pre>'
    echo '<p>'Writing state to disk
    sync
    footer
}


do_delete()
{
    check_usb_device

    header Delete packages
    cat <<EOF
<h2>Select packages to delete</h2>
<form action="/cgi-bin/admin/remove" method="get">
<ul class="zpglist">
EOF
    zpkg list |
    sed '/^ /d' |
    while read package version; do
        cat <<EOF
<li><input type="checkbox" name="zpg" value="$package">$package @ $version</li>
EOF
    done
        cat <<EOF
</ul>
<input type="submit" value="Delete">
</form>
EOF
    footer
}


do_remove()
{
    check_usb_device

    header Removing packages
    install_args="$(package_list)"
    cat <<EOF
<p>Running command:
<pre>zpkg remove $install_args</pre>
EOF

    echo '<pre>'
    zpkg remove $install_args  ||
        echo Remove failed with error code $?
    echo '</pre>'
    echo '<p>'Writing state to disk
    sync
    footer
}


do_show_keys()
{
    header Authorised SSH keys
    if [ -e /boot/authorized_keys ]; then
        pre cat /boot/authorized_keys
        cat <<EOF
<form action="/cgi-bin/admin/reset-keys">
<input type="submit" value="Remove all authorised keys">
</form>
EOF
    else
        echo '<p>'No SSH keys authorised
    fi
    footer
}


do_find_keys()
{
    header Add SSH key file
    list_directories find-keys "$1" 'authorized_keys file'
    show_back find-keys "$1"

    if [ -e /mnt"$1"/authorized_keys ]; then
        cat <<EOF
<h2>File $1/authorized_keys</h2>
EOF
        pre cat /mnt"$1"/authorized_keys
        cat <<EOF
<form action="/cgi-bin/admin/add-keys/$1">
<input type="submit" value="Append to authorised keys">
</form>
EOF
    elif [ -z "$dir_list" ]; then
        echo '<p>Nothing found'
    fi
    footer
}


do_add_keys()
{
    header Added keys from $1
    echo '<pre>'
    cat /mnt/$1/authorized_keys >>/boot/authorized_keys
    sync
    echo '</pre>'
    footer
}


do_reset_keys()
{
    check_usb_device

    header All SSH keys reset
    echo '<pre>'
    rm -f /boot/authorized_keys
    echo '</pre>'
    footer
}


# Searches for alternate config.txt file in the location searched for on
# startup, returns path to file or empty string.
find_config()
{
    for config in /mnt/*/panda-config.txt; do
        if [ -e $config ]; then
            echo $config
            return 0
        fi
    done
    return 1
}


do_show_config()
{
    header Network configuration file
    echo '<h2>Current configuration</h2>'
    pre cat /boot/config.txt
    if config="$(find_config)"; then
        config_name=${config#/mnt/}
        echo "<h2>Configuration in $config_name</h2>"
        pre cat $config
cat <<EOF
<form action="/cgi-bin/admin/new-config/$config_name">
<input type="submit" value="Replace configuration">
</form>
EOF
    fi
    footer
}


do_new_config()
{
    check_usb_device

    header Network configuration updated
    echo '<p>'/boot/config.txt replaced by $1
    pre cp /mnt$1 /boot/config.txt
    footer
}


do_invalid()
{
    echo Status: 404 Not Found
    header Invalid command
    footer
}


# Pick up the basic command and decode it.
case "$PATH_INFO" in
/list)          do_list ;;
/mnt*)          do_files "${PATH_INFO#/mnt}" ;;
/install)       do_install ;;
/delete)        do_delete ;;
/remove)        do_remove ;;
/show-keys)     do_show_keys ;;
/find-keys*)    do_find_keys "${PATH_INFO#/find-keys}" ;;
/add-keys/*)    do_add_keys "${PATH_INFO#/add-keys}" ;;
/reset-keys)    do_reset_keys ;;
/show-config)   do_show_config ;;
/new-config/*)  do_new_config "${PATH_INFO#/new-config}" ;;
*)              do_invalid ;;
esac

# pre env
