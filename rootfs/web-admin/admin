#!/usr/bin/env python

import sys
import os
import glob
import cgi
import cgitb
import subprocess
import pipes
import urllib

cgitb.enable()


def print_header(title):
    title = cgi.escape(title)
    print '''\
Content-type: text/html

<html>
<head>
<title>%(title)s</title>
<link rel="stylesheet" type="text/css" href="/style.css">
</head>
<body>
<h1>%(title)s</h1>''' % locals()


def print_footer():
    print '''\
<p><a href="/">Top</a>
</body>
</html>'''


def print_action(action, title, path=None):
    if path is not None:
        action = '%s/%s' % (action, cgi.escape(path))
    print '''\
<form action="/cgi-bin/admin/%s">
<input type="submit" value="%s">
</form>''' % (action, title)


def fail(message):
    print_header('Action failed')
    print '<p>', cgi.escape(message)
    cgi.print_environ()
    print_footer()
    sys.exit()


def run_command(pre_class, *command):
    print '<pre class="%s">' % pre_class
    cmd = subprocess.Popen(command,
        stderr = subprocess.STDOUT, stdout = subprocess.PIPE)
    for line in cmd.stdout:
        sys.stdout.write('<div>%s</div>' % cgi.escape(line[:-1]))
    print '</pre>'


def is_dir(file):
    return os.path.isdir(file) and not os.path.islink(file)


def list_directories(action, path, title):
    # Enumerate true directories under /mnt
    dirs = [
        os.path.join(path, file)
        for file in os.listdir(os.path.join('/mnt', path))
        if is_dir(os.path.join('/mnt', path, file))]

    if dirs:
        print '<h2>Select directory containing %s:</h2>' % title
        print '<ul class="dirlist">'
        for dir in sorted(dirs):
            print '<li><a href="/cgi-bin/admin/%s/%s">%s</a></li>' % (
                action, urllib.quote(dir), cgi.escape(dir))
        print '</ul>'

    return dirs


def show_back(action, path):
    up, here = os.path.split(path)
    if up:
        print '''\
<p>Up to <a href="/cgi-bin/admin/%s/%s">%s</a>''' % (
            action, cgi.escape(up, True), cgi.escape(up))


# Simple validation: just check for presence of mounted usb device
def check_usb_device():
    return subprocess.call(['grep', '-q', ' /mnt/sd.*', '/proc/mounts']) == 0


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Package management


def do_list():
    print_header('Installed packages')
    zpkg_list = subprocess.Popen(
        ['zpkg', 'list'], stdout = subprocess.PIPE).stdout.readlines()
    if zpkg_list:
        print '''\
<form action="/cgi-bin/admin/remove" method="get">
<div class="zpglist">'''
        for line in sorted(zpkg_list):
            package, version = line.split()
            print '''\
<label>
<input class="zpglist" type="checkbox" name="zpg" value="%s">%s @ %s''' % (
                cgi.escape(package, True), cgi.escape(package),
                cgi.escape(version))
            run_command('zpglist', 'zpkg', 'show', package)
            print '</label>'
        print '''\
</div>
<input type="submit" value="Delete selected packages">
</form>'''
    else:
        print '<p>No packages installed'
    print_footer()


def do_files(path):
    print_header('Looking for packages in /mnt/%s' % path)
    dirs = list_directories('mnt', path, 'packages to install')

    # See if this directory contains any packages
    zpkg_list = glob.glob(os.path.join('/mnt', path, '*@*.zpg'))
    if zpkg_list:
        print '''\
<h2>Select packages to install:</h2>
<form action="/cgi-bin/admin/install" method="get">
<ul class="zpglist">'''
        for file in sorted(zpkg_list):
            print '''\
<li><input type="checkbox" name="zpg" value="%s">%s</li>''' % (
                cgi.escape(file, True), cgi.escape(os.path.split(file)[1]))
        print '''\
</ul>
<input type="submit" value="Install Selected">
</form>'''

    if not dirs and not zpkg_list:
        print '<p>Nothing found'

    show_back('mnt', path)
    print_footer()


# Performs an install or remove transaction
def transaction(title, action):
    print_header(title + ' packages')
    packages = cgi.FieldStorage().getlist('zpg')
    if packages:
        print '<p>%s: %s' % (title, ', '.join(map(cgi.escape, packages)))
        run_command('transcript', 'zpkg', action, *packages)
        print '<p>Writing state to disk'
        subprocess.call('sync')
    else:
        print '<p>Nothing to %s' % action
    print_footer()


def do_install():
    transaction('Installing', 'install')


def do_remove():
    transaction('Removing', 'remove')


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# SSH key administration


def do_show_keys():
    print_header('Authorised SSH keys')
    if os.path.isfile('/boot/authorized_keys'):
        run_command('ssh-keys', 'cat', '/boot/authorized_keys')
        print_action('reset-keys', 'Remove all authorized keys')
    else:
        print '<p>No SSH keys authorised'
    print_footer()


def do_find_keys(path):
    print_header('Add SSH key file')
    dirs = list_directories('find-keys', path, 'authorized_keys file')
    show_back('find-keys', path)

    keys = os.path.join('/mnt', path, 'authorized_keys')
    if os.path.isfile(keys):
        print '<h2>File %s</h2>' % cgi.escape(keys)
        run_command('ssh-keys', 'cat', keys)
        print_action('add-keys', 'Append to authorised keys', path)
    elif not dirs:
        print '<p>Nothing found'
    print_footer()


def do_add_keys(path):
    keys = os.path.join('/mnt', path, 'authorized_keys')
    print_header('Added keys from %s' % keys)
    # We need to use the shell to do this.
    subprocess.call(
        'cat %s >>/boot/authorized_keys' % pipes.quote(keys), shell = True)
    print_footer()


def do_reset_keys():
    print_header('All SSH keys reset')
    os.unlink('/boot/authorized_keys')
    print_footer()


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Network configuration etc


def do_show_config():
    boot_config = open('/tmp/config_file').read()[:-1]
    print_header('Network configuration file')
    print '''\
Configuration loaded from <samp>%s</samp>.
<h2>Configuration in <samp>/boot/config.txt</samp></h2>''' % \
        cgi.escape(boot_config)
    run_command('config', 'cat', '/boot/config.txt')

    new_config = glob.glob('/mnt/*/panda-config.txt')
    if new_config:
        new_config = new_config[0]
        print '<h2>Configuration in <samp>%s</samp></h2>' % \
            cgi.escape(new_config)
        run_command('config', 'cat', new_config)
        print_action('new-config', 'Replace configuration', new_config[4:])
    print_footer()


def do_new_config(path):
    print_header('Network configuration updated')
    subprocess.call(['cp', os.path.join('/mnt', path), '/boot/config.txt'])
    subprocess.call(['sync'])
    print '<p>/boot/config.txt replaced by %s' % cgi.escape(path)
    print_footer()


def do_show_log():
    print_header('Content of /var/log/messages')
    run_command('log', 'cat', '/var/log/messages')
    print_footer()


def do_restart():
    print_header('Restarting installed services')
    run_command('restart', '/etc/init.d/zpkg-daemon', 'restart')
    print_footer()


def do_reboot(path):
    if path == 'confirm':
        print_header('Rebooting')
        print '<p>Wait at least 15 seconds for reboot to complete'
        print_footer()
        subprocess.call(['sync'])
        subprocess.call(['reboot'])
    else:
        print_header('Confirm machine reboot')
        print_action('reboot', 'Reboot', 'confirm')
        print_footer()


def do_invalid(path):
    print 'Status: 404 Not Found'
    print_header('Invalid command')
    print_footer()


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Top level action parse and dispatch

# Arguments are:
#   Action to perform
#   Whether path can be passed as argument
#   Whether we need to check for presence of USB key
parse_actions = {
    'list':         (do_list,           False,  False),
    'mnt':          (do_files,          True,   False),
    'install':      (do_install,        False,  False),
    'remove':       (do_remove,         False,  True),
    'show-keys':    (do_show_keys,      False,  False),
    'find-keys':    (do_find_keys,      True,   False),
    'add-keys':     (do_add_keys,       True,   False),
    'reset-keys':   (do_reset_keys,     False,  True),
    'show-config':  (do_show_config,    False,  False),
    'new-config':   (do_new_config,     True,   True),
    'show-log':     (do_show_log,       False,  False),
    'restart':      (do_restart,        False,  True),
    'reboot':       (do_reboot,         True,   True),
}
default_action =    (do_invalid,        True,   False)


# Disable output buffering
old_stdout = sys.stdout
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)


# Parse request path.  This is of the form /<action>[/<path>] where the path
# part may be unwanted.
path_info = os.environ['PATH_INFO']
split = path_info.split('/', 2)
# At this point split may be anywhere from 1 to 3 elements in length, and we'll
# be pretty put out if the first element isn't an empty string.
if len(split) == 1:
    fail('Need to to specify action')
elif len(split) == 2:
    action = split[1]
    path = ''
else:
    action, path = split[1:3]

action, expect_path, validate = parse_actions.get(action, default_action)
if validate and not check_usb_device():
    fail('Action not allowed')
elif expect_path:
    action(path)
elif path:
    fail('Did not expect path')
else:
    action()
