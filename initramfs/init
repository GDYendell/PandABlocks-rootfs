#!/bin/sh

panic()
{
    echo "$@"
    echo Unable to continue
    exit
}


IMAGEFILE=/boot/imagefile.cpio.gz



# Get our basic working environment up.
mount -t proc proc /proc
mount -t sysfs sysfs /sys
mdev -s


# ------------------------------------------------------------------------------
#
#   SPI configuration and MAC address
#
# Here we ensure that the data partition on the QSPI flash is configured with a
# JFFS2 file system and that the file /qspi/MAC has a valid MAC address.  If
# not, the user will need to enter one.


validate_mac_address()
{
    [ "$(echo "$1" |
         sed 's/OK/xx/g; s/[0-9A-Z][0-9A-Z]/OK/g')" = 'OK:OK:OK:OK:OK:OK' ]
}

check_mac_address()
{
    mount /qspi  &&
    [ -r /qspi/MAC ]  &&
    [ $(stat -c %s /qspi/MAC) = 18 ]  &&
    validate_mac_address "$(cat /qspi/MAC)"
}

format_qspi()
{
    umount /qspi
    flash_erase -j -q /dev/mtd2 0 0  &&
    mount /qspi
}

read_mac_address()
{
    while :; do
        read -p 'Enter MAC address: '
        if validate_mac_address "$REPLY"; then
            echo "$REPLY" >/qspi/MAC
            return
        else
            echo MAC address "$REPLY" failed validation
        fi
    done
}


if ! check_mac_address; then
    format_qspi  &&
    read_mac_address
fi
umount /qspi



# ------------------------------------------------------------------------------
#
#   SD card partitioning
#
# Here we check for the presence of the rootfs -- if present we assume that
# partitioning is good unless the file /boot/repartition exists.

# All partition sizes in units of "cylinders" of 128x32 512 byte blocks, or 2MB
#
P1_SIZE=64          # /boot     128MB
P2_SIZE=256         # /         512MB
# Remaining partition occupies rest of device


need_to_partition()
{
    # Enable forced repartition, but only if a rootfs imagefile is present.
    [ -e /boot/repartition -a -e $IMAGEFILE ]  ||
    # Otherwise try to mount the rootfs and check for the version file
    ! mount /rootfs || ! [ -e /rootfs/etc/version ]
}


partition_sd_card()
{
    # First grab a copy of what's currently on the card and unmount it
    echo Taking snapshot of existing boot partition
    tar cf /tmp/boot.tar -C /boot .  &&
    umount /boot  &&

    cat <<EOF | sed 's/ *#.*//' | fdisk -H128 -S32 /dev/mmcblk0  &&
o       # Reset partition table
n       # Create new partition
p       # Primary
1       # number 1

$P1_SIZE
t       # Set partition type
b       # Win95 FAT32
n
p
2

+$P2_SIZE
n
p
3


p
w       # Write the new partition
EOF

    # Create FAT file system and restore the original data
    mkfs.vfat -v -n BOOT /dev/mmcblk0p1  &&
    mount /boot  &&
    tar xf /tmp/boot.tar -C /boot  &&

    # Create the data file system -- the rootfs file system will be created at
    # the next step.
    mkfs.ext4 -F /dev/mmcblk0p3
}


mount /boot  ||  panic 'Unable to mount boot partition!'
if need_to_partition; then
    umount /rootfs
    partition_sd_card
fi


# ------------------------------------------------------------------------------
#
#   Install rootfs
#
# If the imagefile is present then install it and delete from disk.

install_rootfs()
{
    umount /rootfs

    mkfs.ext4 -F /dev/mmcblk0p2  &&
    mount /rootfs  &&
    cd /rootfs  &&
    gunzip -c $IMAGEFILE | cpio -i  &&
    # This is best run once, here is a good time to do it.
    chroot /rootfs /sbin/ldconfig  &&
    cd /
}

if [ -e $IMAGEFILE ]; then
    install_rootfs
    rm $IMAGEFILE
    mount -o remount,ro /rootfs
else
    mount -o ro /rootfs
fi


# ------------------------------------------------------------------------------
#
#   Switch to rootfs
#

sync
umount /boot
umount /sys
umount /proc
exec switch_root -c /dev/console /rootfs /sbin/init
