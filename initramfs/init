#!/bin/sh

IMAGEFILE=/boot/imagefile.cpio.gz


# Get our basic working environment up.
mount -t proc proc /proc
mount -t sysfs sysfs /sys
mdev -s


# ------------------------------------------------------------------------------
#
#   Status Indicator
#
# We use an LED to indicate boot progress and whether there's been a problem.

panic()
{
    echo >&2 "$@"
    echo >&2 Unable to continue
    touch /tmp/panic
    exec /bin/sh
}

tick()
{
    echo 1 >/sys/class/gpio/gpio953/value
    usleep ${1}000
    echo 0 >/sys/class/gpio/gpio953/value
    usleep ${2}000
}

ticker()
{
    while :; do
        if [ -e /tmp/panic ]; then
            # Urgent panic!
            tick 100 100; tick 100 100; tick 100 300    # S
            tick 300 100; tick 300 100; tick 300 300    # O
            tick 100 100; tick 100 100; tick 100 700    # S
        elif [ -e /tmp/mac ]; then
            tick 600 200; tick 600 1000                 # M
        else
            # Default action: fast on/off ticks
            tick 100 100
        fi
    done
}

stop_ticker()
{
    kill $TICKER_ID
    wait $TICKER_ID
    echo 0 >/sys/class/gpio/gpio953/value
}


# Enable the LED
echo 953 >/sys/class/gpio/export
echo out >/sys/class/gpio/gpio953/direction

ticker &
TICKER_ID=$!


# ------------------------------------------------------------------------------
#
#   Mounting /boot, now ready to roll.

set -x

# Mounting /boot isn't altogether straightforward as the SD card may or may not
# be partitioned, so we have to try both mmcblk0p1 and mmcblk0
mount /boot  ||
mount -t vfat /dev/mmcblk0 /boot  ||
    panic 'Unable to mount boot partition!'


# ------------------------------------------------------------------------------
#
#   QSPI configuration and MAC address
#
# Here we ensure that the data partition on the QSPI flash is configured with a
# JFFS2 file system and that the file /qspi/MAC has a valid MAC address.  If
# not, the user will need to enter one.


validate_mac_address()
{
    [ "$(echo "$1" |
         sed 's/OK/xx/g; s/[0-9A-F][0-9A-F]/OK/g')" = 'OK:OK:OK:OK:OK:OK' ]
}

check_mac_address()
{
    mount /qspi  &&
    [ -r /qspi/MAC ]  &&
    [ $(stat -c %s /qspi/MAC) = 18 ]  &&
    validate_mac_address "$(cat /qspi/MAC)"
}

format_qspi()
{
    mountpoint -q /qspi  &&  umount /qspi

    echo Erasing QSPI
    flash_erase -j -q /dev/mtd2 0 0  &&
    mount /qspi
}

read_mac_address()
{
    touch /tmp/mac
    while :; do
        echo >&2
        echo >&2 ------------------------------------
        read -p 'Enter MAC address: '
        if validate_mac_address "$REPLY"; then
            break
        else
            echo >&2 MAC address "$REPLY" failed validation
        fi
    done

    echo "$REPLY" >/qspi/MAC
    rm /tmp/mac
}

configure_mac_address()
{
    if [ -e /boot/MAC ]  &&  validate_mac_address "$(cat /boot/MAC)"; then
        cp /boot/MAC /qspi/MAC
    else
        read_mac_address
    fi
}


fdisk -l /dev/mmcblk0

if ! check_mac_address; then
    format_qspi  &&
    configure_mac_address
fi
rm -f /boot/MAC
umount /qspi


# ------------------------------------------------------------------------------
#
#   SD card partitioning
#
# Here we check for the presence of the rootfs -- if present we assume that
# partitioning is good unless the file /boot/repartition exists.


need_to_partition()
{
    # Enable forced repartition, but only if a rootfs imagefile is present.
    [ -e /boot/repartition -a -e $IMAGEFILE ]  ||
    # Otherwise try to mount the rootfs and check for the version file.
    ! mount /rootfs || ! [ -e /rootfs/etc/version ]

    # Unmount the rootfs at this point to simplify later processing.
    local result=$?
    mountpoint -q /rootfs  &&  umount /rootfs
    return $result
}

backup_sd_card()
{
    tar cf /tmp/boot.tar -C /boot .  &&
    umount /boot  ||

    panic 'SD card backup failed'
}

partition_sd_card()
{
    # We need to partition in rather strange units: "cylinders" of 255*63
    # blocks.  Discover the device size and convert to cylinders.
    SIZE=$(cat /sys/block/mmcblk0/size)  &&
    CYLINDERS=$((SIZE / 255 / 63))  &&

    dd if=/dev/zero of=/dev/mmcblk0 count=2  &&
    cat <<EOF | sed 's/ *#.*//' | fdisk -H255 -S63 /dev/mmcblk0  &&
x       # Advanced menu
c       # Force number of cylinders
$CYLINDERS
r
n       # Create new partition
p       # Primary
1       # number 1

+128M   # 128M for /boot
n
p
2

+512M   # 512M for /
n
p
3

        # The rest for /opt
a       # Make first partition bootable
1
t       # Set partition types
1
c       # /boot             Win95 FAT32
t
2
83      # / (or /rootfs)    Linux
t
3
83      # /opt              Linux
p
w       # Write the new partition
EOF

    # Reload the partition table and refresh the devices
    hdparm -z /dev/mmcblk0  &&
    mdev -s  ||

    panic 'SD card partitioning failed'
}

format_sd_card()
{
    # Create FAT file system and restore the original data
    mkfs.vfat -v -n boot /dev/mmcblk0p1  &&
    mount /boot  &&
    tar xf /tmp/boot.tar -C /boot  &&

    # Create the data file system -- the rootfs file system will be created at
    # the next step.
    mkfs.ext4 -F /dev/mmcblk0p3  ||

    panic 'SD card formatting failed'
}


if need_to_partition; then
    backup_sd_card
    partition_sd_card
    format_sd_card
fi


# ------------------------------------------------------------------------------
#
#   Install rootfs
#
# If the imagefile is present then install it and delete from disk.

install_rootfs()
{
    mkfs.ext4 -F /dev/mmcblk0p2  &&
    mount /rootfs  &&
    cd /rootfs  &&
    gunzip -c $IMAGEFILE | cpio -i  &&
    cd /  &&

    # Prevent reinstall on next reboot
    rm $IMAGEFILE  ||

    panic 'Unable to install rootfs'
}


if [ -e $IMAGEFILE ]; then
    echo Installing root filesystem
    install_rootfs
    mount -o remount,ro /rootfs
else
    mount -o ro /rootfs
fi


# ------------------------------------------------------------------------------
#
#   Switch to rootfs
#

stop_ticker

sync
umount /boot
umount /sys
umount /proc
exec switch_root -c /dev/console /rootfs /sbin/init
